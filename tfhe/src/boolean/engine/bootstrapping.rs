#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
// Supress not FFI-safe warning
#![allow(improper_ctypes)]

use crate::boolean::ciphertext::Ciphertext;
use crate::boolean::{ClientKey, PLAINTEXT_TRUE};
use crate::core_crypto::algorithms::*;
use crate::core_crypto::commons::computation_buffers::ComputationBuffers;
use crate::core_crypto::commons::generators::{DeterministicSeeder, EncryptionRandomGenerator};
use crate::core_crypto::commons::math::random::{ActivatedRandomGenerator, Seeder};
use crate::core_crypto::commons::parameters::CiphertextModulus;
use crate::core_crypto::entities::*;
use crate::core_crypto::fft_impl::fft64::math::fft::Fft;
use serde::{Deserialize, Serialize};
use std::error::Error;
use std::os::raw::c_void;

// use std::time::Instant;

#[cfg(feature = "fpga")]
use {
    crate::boolean::prelude::{
        DEMO_PARAMETERS, FPGA_BOOTSTRAP_PACKING, MEM_LWE_IN_SIZE, MEM_LWE_OUT_SIZE,
    },
    crate::core_crypto::fft_impl::common::pbs_modulus_switch,
    crate::core_crypto::prelude::polynomial_algorithms::polynomial_wrapping_monic_monomial_mul_assign,
    crate::core_crypto::prelude::*,
    std::env,
    std::ffi::CString,
    std::process,
};

#[cfg(feature = "fpga")]
include!(concat!(env!("OUT_DIR"), "/bindings.rs"));

/// Memory used as buffer for the bootstrap
///
/// It contains contiguous chunk which is then sliced and converted
/// into core's View types.
#[derive(Clone, Default)]
pub struct Memory {
    buffer: Vec<u32>,
}

impl Memory {
    /// Return a tuple with buffers that matches the server key.
    ///
    /// - The first element is the accumulator for bootstrap step.
    /// - The second element is a lwe buffer where the result of the of the bootstrap should be
    ///   written
    pub fn as_buffers(
        &mut self,
        server_key: &ServerKey,
    ) -> (GlweCiphertextView<'_, u32>, LweCiphertextMutView<'_, u32>) {
        let num_elem_in_accumulator = server_key.bootstrapping_key.glwe_size().0
            * server_key.bootstrapping_key.polynomial_size().0;
        let num_elem_in_lwe = server_key
            .bootstrapping_key
            .output_lwe_dimension()
            .to_lwe_size()
            .0;
        let total_elem_needed = num_elem_in_accumulator + num_elem_in_lwe;

        let all_elements = if self.buffer.len() < total_elem_needed {
            self.buffer.resize(total_elem_needed, 0u32);
            self.buffer.as_mut_slice()
        } else {
            &mut self.buffer[..total_elem_needed]
        };

        let (accumulator_elements, lwe_elements) =
            all_elements.split_at_mut(num_elem_in_accumulator);

        {
            let mut accumulator = GlweCiphertextMutView::from_container(
                accumulator_elements,
                server_key.bootstrapping_key.polynomial_size(),
                CiphertextModulus::new_native(),
            );

            accumulator.get_mut_mask().as_mut().fill(0u32);
            accumulator.get_mut_body().as_mut().fill(PLAINTEXT_TRUE);
        }

        let accumulator = GlweCiphertextView::from_container(
            accumulator_elements,
            server_key.bootstrapping_key.polynomial_size(),
            CiphertextModulus::new_native(),
        );

        let lwe =
            LweCiphertextMutView::from_container(lwe_elements, CiphertextModulus::new_native());

        (accumulator, lwe)
    }
}

/// A structure containing the server public key.
///
/// This server key data lives on the CPU.
///
/// The server key is generated by the client and is meant to be published: the client
/// sends it to the server so it can compute homomorphic Boolean circuits.
///
/// In more details, it contains:
/// * `bootstrapping_key` - a public key, used to perform the bootstrapping operation.
/// * `key_switching_key` - a public key, used to perform the key-switching operation.
#[derive(Clone, Serialize, Deserialize)]
pub struct ServerKey {
    pub bootstrapping_key: FourierLweBootstrapKeyOwned,
    pub key_switching_key: LweKeyswitchKeyOwned<u32>,
}

impl ServerKey {
    pub fn bootstrapping_key_size_elements(&self) -> usize {
        self.bootstrapping_key.as_view().data().as_ref().len()
    }

    pub fn bootstrapping_key_size_bytes(&self) -> usize {
        std::mem::size_of_val(self.bootstrapping_key.as_view().data())
    }

    pub fn key_switching_key_size_elements(&self) -> usize {
        self.key_switching_key.as_ref().len()
    }

    pub fn key_switching_key_size_bytes(&self) -> usize {
        std::mem::size_of_val(self.key_switching_key.as_ref())
    }
}

/// A structure containing the compressed server public key.
///
/// This server key data lives on the CPU.
///
/// The server key is generated by the client and is meant to be published: the client
/// sends it to the server so it can compute homomorphic Boolean circuits.
///
/// In more details, it contains:
/// * `bootstrapping_key` - a public key, used to perform the bootstrapping operation.
/// * `key_switching_key` - a public key, used to perform the key-switching operation.
#[derive(Clone, Serialize, Deserialize)]
pub struct CompressedServerKey {
    pub(crate) bootstrapping_key: SeededLweBootstrapKeyOwned<u32>,
    pub(crate) key_switching_key: SeededLweKeyswitchKeyOwned<u32>,
}

/// Perform ciphertext bootstraps on the CPU
pub struct Bootstrapper {
    pub memory: Memory,
    /// A structure containing two CSPRNGs to generate material for encryption like public masks
    /// and secret errors.
    ///
    /// The [`EncryptionRandomGenerator`] contains two CSPRNGs, one publicly seeded used to
    /// generate mask coefficients and one privately seeded used to generate errors during
    /// encryption.
    pub(crate) encryption_generator: EncryptionRandomGenerator<ActivatedRandomGenerator>,
    pub(crate) computation_buffers: ComputationBuffers,
    pub(crate) seeder: DeterministicSeeder<ActivatedRandomGenerator>,
    pub mem_lwe_in: *mut c_void,
    pub mem_lwe_out: *mut c_void,
    pub runner_krnl: *mut c_void,
    pub is_fpga_enabled: bool,
}

impl Bootstrapper {
    pub fn new(seeder: &mut dyn Seeder) -> Self {
        Bootstrapper {
            memory: Default::default(),
            encryption_generator: EncryptionRandomGenerator::<_>::new(seeder.seed(), seeder),
            computation_buffers: Default::default(),
            seeder: DeterministicSeeder::<_>::new(seeder.seed()),
            // FPGA initialisation stuff
            mem_lwe_in: std::ptr::null_mut(),
            mem_lwe_out: std::ptr::null_mut(),
            runner_krnl: std::ptr::null_mut(),
            is_fpga_enabled: false,
        }
    }

    pub fn enable_fpga(&mut self) {
        #[cfg(feature = "fpga")]
        unsafe {
            if self.is_fpga_enabled == false {
                let env_var_FPGA_IMAGE = match env::var("FPGA_IMAGE") {
                    Ok(val) => val,
                    Err(_) => {
                        eprintln!("The FPGA_IMAGE environment variable is not set.");
                        process::exit(1);
                    }
                };

                let env_var_fpga_index = match env::var("FPGA_INDEX") {
                    Ok(val) => match val.parse::<u32>() {
                        Ok(parsed_val) => parsed_val,
                        Err(_) => {
                            // Handle the case when the value cannot be parsed as an integer
                            eprintln!("The value of FPGA_INDEX is not a valid integer.");
                            return;
                        }
                    },
                    Err(_) => {
                        eprintln!("The FPGA_INDEX environment variable is not set.");
                        process::exit(1);
                    }
                };

                let dev = xrtDeviceOpen(env_var_fpga_index);
                let file_path = CString::new(env_var_FPGA_IMAGE).unwrap();
                let xclbin = xrtXclbinAllocFilename(file_path.as_ptr());
                xrtDeviceLoadXclbinHandle(dev, xclbin);

                // Get Kernel UUID
                let mut kernel_uuid = vec![0u8; 16];
                let kernel_uuid_ptr = kernel_uuid.as_mut_ptr();
                xrtDeviceGetXclbinUUID(dev, kernel_uuid_ptr);

                // create Kernel objects
                let cptr_krnl = CString::new("accel").unwrap();
                let kernel: xrtKernelHandle =
                    xrtPLKernelOpenExclusive(dev, kernel_uuid_ptr, cptr_krnl.as_ptr());

                let krnl_grp_0 = xrtKernelArgGroupId(kernel, 0) as u32;
                let krnl_grp_1 = xrtKernelArgGroupId(kernel, 1) as u32;

                self.mem_lwe_in = xrtBOAlloc(dev, MEM_LWE_IN_SIZE, 0u64, krnl_grp_0);
                self.mem_lwe_out = xrtBOAlloc(dev, MEM_LWE_OUT_SIZE, 0u64, krnl_grp_1);
                self.runner_krnl = xrtRunOpen(kernel);
                xrtRunSetArg(self.runner_krnl, 0, self.mem_lwe_in);
                xrtRunSetArg(self.runner_krnl, 1, self.mem_lwe_out);

                self.is_fpga_enabled = true;
            }
        }
    }

    pub(crate) fn new_server_key(
        &mut self,
        cks: &ClientKey,
    ) -> Result<ServerKey, Box<dyn std::error::Error>> {
        let standard_bootstraping_key: LweBootstrapKeyOwned<u32> =
            par_allocate_and_generate_new_lwe_bootstrap_key(
                &cks.lwe_secret_key,
                &cks.glwe_secret_key,
                cks.parameters.pbs_base_log,
                cks.parameters.pbs_level,
                cks.parameters.glwe_modular_std_dev,
                CiphertextModulus::new_native(),
                &mut self.encryption_generator,
            );

        // creation of the bootstrapping key in the Fourier domain
        let mut fourier_bsk = FourierLweBootstrapKey::new(
            standard_bootstraping_key.input_lwe_dimension(),
            standard_bootstraping_key.glwe_size(),
            standard_bootstraping_key.polynomial_size(),
            standard_bootstraping_key.decomposition_base_log(),
            standard_bootstraping_key.decomposition_level_count(),
        );

        let fft = Fft::new(standard_bootstraping_key.polynomial_size());
        let fft = fft.as_view();
        self.computation_buffers.resize(
            convert_standard_lwe_bootstrap_key_to_fourier_mem_optimized_requirement(fft)
                .unwrap()
                .unaligned_bytes_required(),
        );
        let stack = self.computation_buffers.stack();

        // Conversion to fourier domain
        convert_standard_lwe_bootstrap_key_to_fourier_mem_optimized(
            &standard_bootstraping_key,
            &mut fourier_bsk,
            fft,
            stack,
        );

        // Convert the GLWE secret key into an LWE secret key:
        let big_lwe_secret_key = cks.glwe_secret_key.clone().into_lwe_secret_key();

        // creation of the key switching key
        let ksk = allocate_and_generate_new_lwe_keyswitch_key(
            &big_lwe_secret_key,
            &cks.lwe_secret_key,
            cks.parameters.ks_base_log,
            cks.parameters.ks_level,
            cks.parameters.lwe_modular_std_dev,
            CiphertextModulus::new_native(),
            &mut self.encryption_generator,
        );

        Ok(ServerKey {
            bootstrapping_key: fourier_bsk,
            key_switching_key: ksk,
        })
    }

    pub(crate) fn new_compressed_server_key(
        &mut self,
        cks: &ClientKey,
    ) -> Result<CompressedServerKey, Box<dyn std::error::Error>> {
        #[cfg(not(feature = "__wasm_api"))]
        let bootstrapping_key = par_allocate_and_generate_new_seeded_lwe_bootstrap_key(
            &cks.lwe_secret_key,
            &cks.glwe_secret_key,
            cks.parameters.pbs_base_log,
            cks.parameters.pbs_level,
            cks.parameters.glwe_modular_std_dev,
            CiphertextModulus::new_native(),
            &mut self.seeder,
        );

        #[cfg(feature = "__wasm_api")]
        let bootstrapping_key = allocate_and_generate_new_seeded_lwe_bootstrap_key(
            &cks.lwe_secret_key,
            &cks.glwe_secret_key,
            cks.parameters.pbs_base_log,
            cks.parameters.pbs_level,
            cks.parameters.glwe_modular_std_dev,
            CiphertextModulus::new_native(),
            &mut self.seeder,
        );

        let big_lwe_secret_key = cks.glwe_secret_key.clone().into_lwe_secret_key();

        // creation of the key switching key
        let key_switching_key = allocate_and_generate_new_seeded_lwe_keyswitch_key(
            &big_lwe_secret_key,
            &cks.lwe_secret_key,
            cks.parameters.ks_base_log,
            cks.parameters.ks_level,
            cks.parameters.lwe_modular_std_dev,
            CiphertextModulus::new_native(),
            &mut self.seeder,
        );

        Ok(CompressedServerKey {
            bootstrapping_key,
            key_switching_key,
        })
    }

    pub fn bootstrap(
        &mut self,
        input: &LweCiphertextOwned<u32>,
        server_key: &ServerKey,
    ) -> Result<LweCiphertextOwned<u32>, Box<dyn Error>> {
        let (accumulator, mut buffer_after_pbs) = self.memory.as_buffers(server_key);

        let fourier_bsk = &server_key.bootstrapping_key;

        let fft = Fft::new(fourier_bsk.polynomial_size());
        let fft = fft.as_view();

        self.computation_buffers.resize(
            programmable_bootstrap_lwe_ciphertext_mem_optimized_requirement::<u64>(
                fourier_bsk.glwe_size(),
                fourier_bsk.polynomial_size(),
                fft,
            )
            .unwrap()
            .unaligned_bytes_required(),
        );
        let stack = self.computation_buffers.stack();

        programmable_bootstrap_lwe_ciphertext_mem_optimized(
            input,
            &mut buffer_after_pbs,
            &accumulator,
            fourier_bsk,
            fft,
            stack,
        );

        Ok(LweCiphertext::from_container(
            buffer_after_pbs.as_ref().to_owned(),
            input.ciphertext_modulus(),
        ))
    }

    pub(crate) fn keyswitch(
        &mut self,
        input: &LweCiphertextOwned<u32>,
        server_key: &ServerKey,
    ) -> Result<LweCiphertextOwned<u32>, Box<dyn Error>> {
        // Allocate the output of the KS
        let mut output = LweCiphertext::new(
            0u32,
            server_key
                .bootstrapping_key
                .input_lwe_dimension()
                .to_lwe_size(),
            input.ciphertext_modulus(),
        );

        keyswitch_lwe_ciphertext(&server_key.key_switching_key, input, &mut output);

        Ok(output)
    }

    pub fn bootstrap_and_keyswitch_packed(
        &mut self,
        ciphertexts: &mut Vec<LweCiphertextOwned<u32>>,
        _server_key: &ServerKey,
    ) -> Vec<Ciphertext> {
        #[cfg(not(feature = "fpga"))]
        let bootstrapped = {
            // let start = Instant::now();
            let result: Vec<LweCiphertextOwned<u32>> = ciphertexts
                .iter_mut()
                .map(|ct| self.bootstrap(ct, _server_key).unwrap())
                .collect();
            // println!(
            //     "{:?} SW bootstraps: {:?} ",
            //     ciphertexts.len(),
            //     start.elapsed()
            // );
            result
        };

        #[cfg(feature = "fpga")]
        let bootstrapped: Vec<LweCiphertextOwned<u32>> = if !self.is_fpga_enabled {
            // let start = Instant::now();
            let result: Vec<LweCiphertextOwned<u32>> = ciphertexts
                .iter_mut()
                .map(|ct| self.bootstrap(ct, _server_key).unwrap())
                .collect();
            // println!(
            //     "{:?} SW bootstraps: {:?} ",
            //     ciphertexts.len(),
            //     start.elapsed()
            // );
            result
        } else {
            assert!(ciphertexts.len() <= FPGA_BOOTSTRAP_PACKING);

            fn alternate_extract_lwe_sample_from_glwe_ciphertext(
                input_glwe: &GlweCiphertext<Vec<u32>>,
                output_lwe: &mut LweCiphertext<Vec<u32>>,
                mut nth: usize,
            ) {
                // We retrieve the bodies and masks of the two ciphertexts.
                let (mut lwe_mask, lwe_body) = output_lwe.get_mut_mask_and_body();
                let (glwe_mask, glwe_body) = input_glwe.get_mask_and_body();

                nth = nth % (2 * input_glwe.polynomial_size().0);

                // We copy the body
                *lwe_body.data = if nth >= input_glwe.polynomial_size().0 {
                    u32::MAX - glwe_body.as_ref()[nth % input_glwe.polynomial_size().0]
                } else {
                    glwe_body.as_ref()[nth % input_glwe.polynomial_size().0]
                };

                // We copy the mask (each polynomial is in the wrong order)
                lwe_mask.as_mut().copy_from_slice(glwe_mask.as_ref());

                // We loop through the polynomials
                for lwe_mask_poly in lwe_mask.as_mut().chunks_mut(input_glwe.polynomial_size().0) {
                    let mut poly: Polynomial<&mut [u32]> =
                        Polynomial::from_container(lwe_mask_poly);
                    // We reverse the polynomial
                    poly.reverse();
                    // We do the final monomial mul
                    polynomial_wrapping_monic_monomial_mul_assign(
                        &mut poly,
                        MonomialDegree(nth + glwe_mask.polynomial_size().0 + 1),
                    );
                }
            }

            let mut lwe_out = [[0u32;
                DEMO_PARAMETERS.polynomial_size.0 * (DEMO_PARAMETERS.glwe_dimension.0 + 1)];
                FPGA_BOOTSTRAP_PACKING];

            let modulus_switch = |num: &u32| -> u32 {
                pbs_modulus_switch(
                    *num,
                    DEMO_PARAMETERS.polynomial_size,
                    ModulusSwitchOffset(0),
                    LutCountLog(0),
                ) as u32
            };

            // ! cts_mask is passed to the FPGA and needs to be contiguous memory
            let cts_mask: Vec<[u32; DEMO_PARAMETERS.lwe_dimension.0]> = ciphertexts
                .iter()
                .map(|ct| {
                    ct.get_mask()
                        .as_ref()
                        .iter()
                        .map(modulus_switch)
                        .collect::<Vec<u32>>()
                        .try_into()
                        .unwrap()
                })
                .collect();

            let ciphertext_moduluses: Vec<CiphertextModulus<u32>> = ciphertexts
                .iter()
                .map(|ct| ct.ciphertext_modulus())
                .collect();

            let cts_bodies: Vec<u32> = ciphertexts
                .iter()
                .map(|ct| modulus_switch(ct.get_body().data))
                .collect();

            unsafe {
                // Write Input
                xrtBOWrite(
                    self.mem_lwe_in,
                    cts_mask.as_ptr() as *const c_void,
                    MEM_LWE_IN_SIZE,
                    0,
                );
                xrtBOSync(
                    self.mem_lwe_in,
                    xclBOSyncDirection_XCL_BO_SYNC_BO_TO_DEVICE,
                    MEM_LWE_IN_SIZE,
                    0,
                );

                // Kernel Run
                // let start = Instant::now();
                xrtRunStart(self.runner_krnl);
                xrtRunWait(self.runner_krnl);
                // println!(
                //     "{:?} FPGA bootstraps: {:?} ",
                //     ciphertexts.len(),
                //     start.elapsed()
                // );

                // Read Output
                xrtBOSync(
                    self.mem_lwe_out,
                    xclBOSyncDirection_XCL_BO_SYNC_BO_FROM_DEVICE,
                    MEM_LWE_OUT_SIZE,
                    0,
                );

                xrtBORead(
                    self.mem_lwe_out,
                    lwe_out.as_mut_ptr() as *mut c_void,
                    MEM_LWE_OUT_SIZE,
                    0,
                );
            }

            let mut result = Vec::<LweCiphertextOwned<u32>>::new();

            for (slot, body, modulus) in itertools::izip!(lwe_out, cts_bodies, ciphertext_moduluses)
            {
                let mut pbs_result = LweCiphertext::new(
                    0u32,
                    LweDimension(
                        DEMO_PARAMETERS.glwe_dimension.0 * DEMO_PARAMETERS.polynomial_size.0,
                    )
                    .to_lwe_size(),
                    modulus,
                );
                let mut input_glwe = GlweCiphertext::from_container(
                    slot.to_vec(),
                    DEMO_PARAMETERS.polynomial_size,
                    modulus,
                );
                alternate_extract_lwe_sample_from_glwe_ciphertext(
                    &mut input_glwe,
                    &mut pbs_result,
                    body as usize,
                );
                result.push(pbs_result);
            }

            unsafe {
                result.set_len(ciphertexts.len());
            }
            result
        };

        #[cfg(feature = "without_keyswitch")]
        let result = bootstrapped
            .iter()
            .map(|ct| Ciphertext::Encrypted(ct.clone()))
            .collect();

        #[cfg(not(feature = "without_keyswitch"))]
        let result = {
            // let start = Instant::now();
            let result = bootstrapped
                .iter()
                .map(|ct| Ciphertext::Encrypted(self.keyswitch(ct, _server_key).unwrap()))
                .collect();
            // print!(
            //     "{:?} SW keyswitches: {:?}",
            //     ciphertexts.len(),
            //     start.elapsed()
            // );
            result
        };

        result
    }

    pub(crate) fn bootstrap_keyswitch(
        &mut self,
        mut ciphertext: LweCiphertextOwned<u32>,
        server_key: &ServerKey,
    ) -> Result<Ciphertext, Box<dyn Error>> {
        let (accumulator, mut buffer_lwe_after_pbs) = self.memory.as_buffers(server_key);

        let fourier_bsk = &server_key.bootstrapping_key;

        let fft = Fft::new(fourier_bsk.polynomial_size());
        let fft = fft.as_view();

        self.computation_buffers.resize(
            programmable_bootstrap_lwe_ciphertext_mem_optimized_requirement::<u64>(
                fourier_bsk.glwe_size(),
                fourier_bsk.polynomial_size(),
                fft,
            )
            .unwrap()
            .unaligned_bytes_required(),
        );
        let stack = self.computation_buffers.stack();

        // Compute a bootstrap
        programmable_bootstrap_lwe_ciphertext_mem_optimized(
            &ciphertext,
            &mut buffer_lwe_after_pbs,
            &accumulator,
            fourier_bsk,
            fft,
            stack,
        );

        // Compute a key switch to get back to input key
        keyswitch_lwe_ciphertext(
            &server_key.key_switching_key,
            &buffer_lwe_after_pbs,
            &mut ciphertext,
        );

        Ok(Ciphertext::Encrypted(ciphertext))
    }
}

impl From<CompressedServerKey> for ServerKey {
    fn from(compressed_server_key: CompressedServerKey) -> Self {
        let CompressedServerKey {
            key_switching_key,
            bootstrapping_key,
        } = compressed_server_key;

        let key_switching_key = key_switching_key.decompress_into_lwe_keyswitch_key();
        let standard_bootstrapping_key = bootstrapping_key.decompress_into_lwe_bootstrap_key();

        let mut bootstrapping_key = FourierLweBootstrapKeyOwned::new(
            standard_bootstrapping_key.input_lwe_dimension(),
            standard_bootstrapping_key.glwe_size(),
            standard_bootstrapping_key.polynomial_size(),
            standard_bootstrapping_key.decomposition_base_log(),
            standard_bootstrapping_key.decomposition_level_count(),
        );

        convert_standard_lwe_bootstrap_key_to_fourier(
            &standard_bootstrapping_key,
            &mut bootstrapping_key,
        );

        Self {
            key_switching_key,
            bootstrapping_key,
        }
    }
}
